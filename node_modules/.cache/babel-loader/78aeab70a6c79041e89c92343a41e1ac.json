{"ast":null,"code":"/**\n * @module ol/render/Feature\n */\nimport GeometryType from '../geom/GeometryType.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { createOrUpdateFromCoordinate, createOrUpdateFromFlatCoordinates, getCenter, getHeight } from '../extent.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray, getInteriorPointsOfMultiArray } from '../geom/flat/interiorpoint.js';\nimport { get as getProjection } from '../proj.js';\nimport { interpolatePoint } from '../geom/flat/interpolate.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { transform2D } from '../geom/flat/transform.js';\n/**\n * @type {import(\"../transform.js\").Transform}\n */\n\nvar tmpTransform = createTransform();\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\n\nvar RenderFeature =\n/** @class */\nfunction () {\n  /**\n   * @param {import(\"../geom/GeometryType.js\").default} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  function RenderFeature(type, flatCoordinates, ends, properties, id) {\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n\n    this.id_ = id;\n    /**\n     * @private\n     * @type {import(\"../geom/GeometryType.js\").default}\n     */\n\n    this.type_ = type;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatCoordinates_ = flatCoordinates;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatMidpoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>|Array<Array<number>>}\n     */\n\n    this.ends_ = ends;\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n\n    this.properties_ = properties;\n  }\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n\n\n  RenderFeature.prototype.get = function (key) {\n    return this.properties_[key];\n  };\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n\n\n  RenderFeature.prototype.getExtent = function () {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === GeometryType.POINT ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n    }\n\n    return this.extent_;\n  };\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  RenderFeature.prototype.getFlatInteriorPoint = function () {\n    if (!this.flatInteriorPoints_) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0,\n      /** @type {Array<number>} */\n      this.ends_, 2, flatCenter, 0);\n    }\n\n    return this.flatInteriorPoints_;\n  };\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  RenderFeature.prototype.getFlatInteriorPoints = function () {\n    if (!this.flatInteriorPoints_) {\n      var flatCenters = linearRingssCenter(this.flatCoordinates_, 0,\n      /** @type {Array<Array<number>>} */\n      this.ends_, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0,\n      /** @type {Array<Array<number>>} */\n      this.ends_, 2, flatCenters);\n    }\n\n    return this.flatInteriorPoints_;\n  };\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n\n\n  RenderFeature.prototype.getFlatMidpoint = function () {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n\n    return this.flatMidpoints_;\n  };\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n\n\n  RenderFeature.prototype.getFlatMidpoints = function () {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      var flatCoordinates = this.flatCoordinates_;\n      var offset = 0;\n      var ends =\n      /** @type {Array<number>} */\n      this.ends_;\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n\n    return this.flatMidpoints_;\n  };\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n\n\n  RenderFeature.prototype.getId = function () {\n    return this.id_;\n  };\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n\n\n  RenderFeature.prototype.getOrientedFlatCoordinates = function () {\n    return this.flatCoordinates_;\n  };\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n\n\n  RenderFeature.prototype.getGeometry = function () {\n    return this;\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n\n\n  RenderFeature.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n    return this;\n  };\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n\n\n  RenderFeature.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {\n    return this;\n  };\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n\n\n  RenderFeature.prototype.getProperties = function () {\n    return this.properties_;\n  };\n  /**\n   * @return {number} Stride.\n   */\n\n\n  RenderFeature.prototype.getStride = function () {\n    return 2;\n  };\n  /**\n   * @return {undefined}\n   */\n\n\n  RenderFeature.prototype.getStyleFunction = function () {\n    return undefined;\n  };\n  /**\n   * Get the type of this feature's geometry.\n   * @return {import(\"../geom/GeometryType.js\").default} Geometry type.\n   * @api\n   */\n\n\n  RenderFeature.prototype.getType = function () {\n    return this.type_;\n  };\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   * The SRS of the source and destination are expected to be the same.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.\n   */\n\n\n  RenderFeature.prototype.transform = function (source, destination) {\n    source = getProjection(source);\n    var pixelExtent = source.getExtent();\n    var projectedExtent = source.getWorldExtent();\n    var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n    composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n    transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n  };\n  /**\n   * @return {Array<number>|Array<Array<number>>} Ends or endss.\n   */\n\n\n  RenderFeature.prototype.getEnds = function () {\n    return this.ends_;\n  };\n\n  return RenderFeature;\n}();\n\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\n/**\n * @return {Array<number>} Flat coordinates.\n */\n\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\nexport default RenderFeature;","map":{"version":3,"sources":["../src/render/Feature.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/render/Feature\n */\nimport GeometryType from '../geom/GeometryType.js';\nimport { compose as composeTransform, create as createTransform, } from '../transform.js';\nimport { createOrUpdateFromCoordinate, createOrUpdateFromFlatCoordinates, getCenter, getHeight, } from '../extent.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray, getInteriorPointsOfMultiArray, } from '../geom/flat/interiorpoint.js';\nimport { get as getProjection } from '../proj.js';\nimport { interpolatePoint } from '../geom/flat/interpolate.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { transform2D } from '../geom/flat/transform.js';\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nvar RenderFeature = /** @class */ (function () {\n    /**\n     * @param {import(\"../geom/GeometryType.js\").default} type Geometry type.\n     * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n     *     to be right-handed for polygons.\n     * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.\n     * @param {Object<string, *>} properties Properties.\n     * @param {number|string|undefined} id Feature id.\n     */\n    function RenderFeature(type, flatCoordinates, ends, properties, id) {\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent|undefined}\n         */\n        this.extent_;\n        /**\n         * @private\n         * @type {number|string|undefined}\n         */\n        this.id_ = id;\n        /**\n         * @private\n         * @type {import(\"../geom/GeometryType.js\").default}\n         */\n        this.type_ = type;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        this.flatCoordinates_ = flatCoordinates;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        this.flatInteriorPoints_ = null;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        this.flatMidpoints_ = null;\n        /**\n         * @private\n         * @type {Array<number>|Array<Array<number>>}\n         */\n        this.ends_ = ends;\n        /**\n         * @private\n         * @type {Object<string, *>}\n         */\n        this.properties_ = properties;\n    }\n    /**\n     * Get a feature property by its key.\n     * @param {string} key Key\n     * @return {*} Value for the requested key.\n     * @api\n     */\n    RenderFeature.prototype.get = function (key) {\n        return this.properties_[key];\n    };\n    /**\n     * Get the extent of this feature's geometry.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    RenderFeature.prototype.getExtent = function () {\n        if (!this.extent_) {\n            this.extent_ =\n                this.type_ === GeometryType.POINT\n                    ? createOrUpdateFromCoordinate(this.flatCoordinates_)\n                    : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n        }\n        return this.extent_;\n    };\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n    RenderFeature.prototype.getFlatInteriorPoint = function () {\n        if (!this.flatInteriorPoints_) {\n            var flatCenter = getCenter(this.getExtent());\n            this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, \n            /** @type {Array<number>} */ (this.ends_), 2, flatCenter, 0);\n        }\n        return this.flatInteriorPoints_;\n    };\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n    RenderFeature.prototype.getFlatInteriorPoints = function () {\n        if (!this.flatInteriorPoints_) {\n            var flatCenters = linearRingssCenter(this.flatCoordinates_, 0, \n            /** @type {Array<Array<number>>} */ (this.ends_), 2);\n            this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, \n            /** @type {Array<Array<number>>} */ (this.ends_), 2, flatCenters);\n        }\n        return this.flatInteriorPoints_;\n    };\n    /**\n     * @return {Array<number>} Flat midpoint.\n     */\n    RenderFeature.prototype.getFlatMidpoint = function () {\n        if (!this.flatMidpoints_) {\n            this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n        }\n        return this.flatMidpoints_;\n    };\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n    RenderFeature.prototype.getFlatMidpoints = function () {\n        if (!this.flatMidpoints_) {\n            this.flatMidpoints_ = [];\n            var flatCoordinates = this.flatCoordinates_;\n            var offset = 0;\n            var ends = /** @type {Array<number>} */ (this.ends_);\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                var end = ends[i];\n                var midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n                extend(this.flatMidpoints_, midpoint);\n                offset = end;\n            }\n        }\n        return this.flatMidpoints_;\n    };\n    /**\n     * Get the feature identifier.  This is a stable identifier for the feature and\n     * is set when reading data from a remote source.\n     * @return {number|string|undefined} Id.\n     * @api\n     */\n    RenderFeature.prototype.getId = function () {\n        return this.id_;\n    };\n    /**\n     * @return {Array<number>} Flat coordinates.\n     */\n    RenderFeature.prototype.getOrientedFlatCoordinates = function () {\n        return this.flatCoordinates_;\n    };\n    /**\n     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n     * determining the geometry type in style function (see {@link #getType}).\n     * @return {RenderFeature} Feature.\n     * @api\n     */\n    RenderFeature.prototype.getGeometry = function () {\n        return this;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {RenderFeature} Simplified geometry.\n     */\n    RenderFeature.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        return this;\n    };\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n     * @return {RenderFeature} Simplified geometry.\n     */\n    RenderFeature.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {\n        return this;\n    };\n    /**\n     * Get the feature properties.\n     * @return {Object<string, *>} Feature properties.\n     * @api\n     */\n    RenderFeature.prototype.getProperties = function () {\n        return this.properties_;\n    };\n    /**\n     * @return {number} Stride.\n     */\n    RenderFeature.prototype.getStride = function () {\n        return 2;\n    };\n    /**\n     * @return {undefined}\n     */\n    RenderFeature.prototype.getStyleFunction = function () {\n        return undefined;\n    };\n    /**\n     * Get the type of this feature's geometry.\n     * @return {import(\"../geom/GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    RenderFeature.prototype.getType = function () {\n        return this.type_;\n    };\n    /**\n     * Transform geometry coordinates from tile pixel space to projected.\n     * The SRS of the source and destination are expected to be the same.\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} source The current projection\n     * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.\n     */\n    RenderFeature.prototype.transform = function (source, destination) {\n        source = getProjection(source);\n        var pixelExtent = source.getExtent();\n        var projectedExtent = source.getWorldExtent();\n        var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n        composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n        transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n    };\n    /**\n     * @return {Array<number>|Array<Array<number>>} Ends or endss.\n     */\n    RenderFeature.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    return RenderFeature;\n}());\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates =\n    RenderFeature.prototype.getOrientedFlatCoordinates;\nexport default RenderFeature;\n//# sourceMappingURL=Feature.js.map"]},"metadata":{},"sourceType":"module"}