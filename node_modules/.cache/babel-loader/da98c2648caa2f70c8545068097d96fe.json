{"ast":null,"code":"/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport RBush from 'rbush/rbush.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, getHeight, getWidth, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextBaseline, drawImageOrLabel } from '../canvas.js';\nimport { defaultTextAlign, measureAndCacheTextWidth, measureTextHeight, measureTextWidths } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} textStates The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} fillStates The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} strokeStates The stroke states (decluttering).\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\n\nvar tmpExtent = createEmpty();\n/**\n * @type {!import(\"../../transform.js\").Transform}\n */\n\nvar tmpTransform = createTransform();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p4 = [];\n\nvar Executor =\n/** @class */\nfunction () {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {SerializableInstructions} instructions The serializable instructions\n   * @param {import(\"../../size.js\").Size} renderBuffer Render buffer (width/height) in pixels.\n   */\n  function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.alignFill_;\n    /**\n     * @type {Array<*>}\n     */\n\n    this.declutterItems = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = instructions.instructions;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = instructions.coordinates;\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {import(\"../../size.js\").Size}\n     */\n\n    this.renderBuffer_ = renderBuffer;\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n\n    this.renderedTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.pixelCoordinates_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = 0;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n\n    this.fillStates = instructions.fillStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n\n    this.strokeStates = instructions.strokeStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n\n    this.textStates = instructions.textStates || {};\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n\n    this.widths_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n\n    this.labels_ = {};\n  }\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n\n\n  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n    var key = text + textKey + fillKey + strokeKey;\n\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n\n    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    var fillState = fillKey ? this.fillStates[fillKey] : null;\n    var textState = this.textStates[textKey];\n    var pixelRatio = this.pixelRatio;\n    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var lines = text.split('\\n');\n    var numLines = lines.length;\n    var widths = [];\n    var width = measureTextWidths(textState.font, lines, widths);\n    var lineHeight = measureTextHeight(textState.font);\n    var height = lineHeight * numLines;\n    var renderWidth = width + strokeWidth;\n    var contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors\n\n    var w = (renderWidth + 2) * scale[0];\n    var h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n\n    var label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n\n    contextInstructions.push('font', textState.font);\n\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit); // eslint-disable-next-line\n\n      var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n\n      if (Context.prototype.setLineDash) {\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n    }\n\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    var leftRight = 0.5 - align;\n    var x = align * renderWidth + leftRight * strokeWidth;\n    var i;\n\n    if (strokeKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('strokeText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n\n    if (fillKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('fillText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n\n    this.labels_[key] = label;\n    return label;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @param {boolean} declutter Declutter.\n   */\n\n\n  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction, declutter) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n\n    if (fillInstruction) {\n      this.alignFill_ =\n      /** @type {boolean} */\n      fillInstruction[2];\n\n      if (declutter) {\n        context.fillStyle =\n        /** @type {import(\"../../colorlike.js\").ColorLike} */\n        fillInstruction[1];\n      }\n\n      this.fill_(context);\n    }\n\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context,\n      /** @type {Array<*>} */\n      strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array<number>} padding Padding.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n\n\n  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    x -= anchorX;\n    y -= anchorY;\n    var w = width + originX > imageOrLabel.width ? imageOrLabel.width - originX : width;\n    var h = height + originY > imageOrLabel.height ? imageOrLabel.height - originY : height;\n    var boxW = padding[3] + w * scale[0] + padding[1];\n    var boxH = padding[0] + h * scale[1] + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    var transform = null;\n\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      applyTransform(tmpTransform, p1);\n      applyTransform(tmpTransform, p2);\n      applyTransform(tmpTransform, p3);\n      applyTransform(tmpTransform, p4);\n      createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n\n    var renderBufferX = 0;\n    var renderBufferY = 0;\n\n    if (declutterGroup) {\n      var renderBuffer = this.renderBuffer_;\n      renderBuffer[0] = Math.max(renderBuffer[0], getWidth(tmpExtent));\n      renderBufferX = renderBuffer[0];\n      renderBuffer[1] = Math.max(renderBuffer[1], getHeight(tmpExtent));\n      renderBufferY = renderBuffer[1];\n    }\n\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * scale[0] / 2 : 0;\n    var intersects = tmpExtent[0] - strokePadding <= (canvas.width + renderBufferX) / contextScale && tmpExtent[2] + strokePadding >= -renderBufferX / contextScale && tmpExtent[1] - strokePadding <= (canvas.height + renderBufferY) / contextScale && tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[0] == 1) {\n        return false;\n      }\n\n      var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, imageOrLabel, originX, originY, w, h, x, y, scale, tmpExtent.slice()] : null;\n\n      if (declutterArgs) {\n        if (fillStroke) {\n          declutterArgs.push(fillInstruction, strokeInstruction, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));\n        }\n\n        declutterGroup.push(declutterArgs);\n      }\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n        /** @type {Array<*>} */\n        fillInstruction,\n        /** @type {Array<*>} */\n        strokeInstruction, false);\n      }\n\n      drawImageOrLabel(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale);\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  Executor.prototype.fill_ = function (context) {\n    if (this.alignFill_) {\n      var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n\n    context.fill();\n\n    if (this.alignFill_) {\n      context.restore();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n\n\n  Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n    context.strokeStyle =\n    /** @type {import(\"../../colorlike.js\").ColorLike} */\n    instruction[1];\n    context.lineWidth =\n    /** @type {number} */\n    instruction[2];\n    context.lineCap =\n    /** @type {CanvasLineCap} */\n    instruction[3];\n    context.lineJoin =\n    /** @type {CanvasLineJoin} */\n    instruction[4];\n    context.miterLimit =\n    /** @type {number} */\n    instruction[5];\n\n    if (context.setLineDash) {\n      context.lineDashOffset =\n      /** @type {number} */\n      instruction[7];\n      context.setLineDash(\n      /** @type {Array<number>} */\n      instruction[6]);\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} opacity Layer opacity.\n   * @param {?} declutterTree Declutter tree.\n   * @return {?} Declutter tree.\n   */\n\n\n  Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {\n    /** @type {Array<import(\"../../structs/RBush.js\").Entry>} */\n    var boxes = [];\n\n    for (var i = 1, ii = declutterGroup.length; i < ii; ++i) {\n      var declutterData = declutterGroup[i];\n      var box = declutterData[11];\n      boxes.push({\n        minX: box[0],\n        minY: box[1],\n        maxX: box[2],\n        maxY: box[3],\n        value: feature\n      });\n    }\n\n    if (!declutterTree) {\n      declutterTree = new RBush(9);\n    }\n\n    var collides = false;\n\n    for (var i = 0, ii = boxes.length; i < ii; ++i) {\n      if (declutterTree.collides(boxes[i])) {\n        collides = true;\n        break;\n      }\n    }\n\n    if (!collides) {\n      declutterTree.load(boxes);\n\n      for (var j = 1, jj = declutterGroup.length; j < jj; ++j) {\n        var declutterData =\n        /** @type {Array} */\n        declutterGroup[j];\n        var context = declutterData[0];\n        var currentAlpha = context.globalAlpha;\n\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = opacity;\n        }\n\n        if (declutterData.length > 12) {\n          this.replayTextBackground_(declutterData[0], declutterData[14], declutterData[15], declutterData[16], declutterData[17], declutterData[12], declutterData[13], true);\n        }\n\n        drawImageOrLabel.apply(undefined, declutterData);\n\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = currentAlpha;\n        }\n      }\n    }\n\n    declutterGroup.length = 1;\n    return declutterTree;\n  };\n  /**\n   * @private\n   * @param {string} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n\n\n  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n    var textState = this.textStates[textKey];\n    var label = this.createLabel(text, textKey, fillKey, strokeKey);\n    var strokeState = this.strokeStates[strokeKey];\n    var pixelRatio = this.pixelRatio;\n    var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor\n\n    var width = label.width / pixelRatio - 2 * textState.scale[0];\n    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T|undefined} featureCallback Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {\n    this.declutterItems.length = 0;\n    /** @type {Array<number>} */\n\n    var pixelCoordinates;\n\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n\n    var i = 0; // instruction index\n\n    var ii = instructions.length; // end of instructions\n\n    var d = 0; // data index\n\n    var dd; // end of per-instruction data\n\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;\n    var strokeKey, fillKey;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    var state =\n    /** @type {import(\"../../render.js\").State} */\n    {\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    }; // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var\n    /** @type {import(\"../../Feature.js\").FeatureLike} */\n    feature;\n    var x, y;\n\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type =\n      /** @type {import(\"./Instruction.js\").default} */\n      instruction[0];\n\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature =\n          /** @type {import(\"../../Feature.js\").FeatureLike} */\n          instruction[1];\n\n          if (!feature.getGeometry()) {\n            i =\n            /** @type {number} */\n            instruction[2];\n          } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, instruction[3])) {\n            i =\n            /** @type {number} */\n            instruction[2] + 1;\n          } else {\n            ++i;\n          }\n\n          break;\n\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.CIRCLE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n\n        case CanvasInstruction.CUSTOM:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd = instruction[2];\n          var geometry =\n          /** @type {import(\"../../geom/SimpleGeometry.js\").default} */\n          instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n\n          var coords = coordinateCache[i];\n\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n\n          renderer(coords, state);\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_IMAGE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          image =\n          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n          anchorX =\n          /** @type {number} */\n          instruction[4];\n          anchorY =\n          /** @type {number} */\n          instruction[5];\n          declutterGroups = featureCallback ? null : instruction[6];\n          var height =\n          /** @type {number} */\n          instruction[7];\n          var opacity =\n          /** @type {number} */\n          instruction[8];\n          var originX =\n          /** @type {number} */\n          instruction[9];\n          var originY =\n          /** @type {number} */\n          instruction[10];\n          var rotateWithView =\n          /** @type {boolean} */\n          instruction[11];\n          var rotation =\n          /** @type {number} */\n          instruction[12];\n          var scale =\n          /** @type {import(\"../../size.js\").Size} */\n          instruction[13];\n          var width =\n          /** @type {number} */\n          instruction[14];\n\n          if (!image && instruction.length >= 19) {\n            // create label images\n            text =\n            /** @type {string} */\n            instruction[18];\n            textKey =\n            /** @type {string} */\n            instruction[19];\n            strokeKey =\n            /** @type {string} */\n            instruction[20];\n            fillKey =\n            /** @type {string} */\n            instruction[21];\n            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            var textOffsetX =\n            /** @type {number} */\n            instruction[22];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            var textOffsetY =\n            /** @type {number} */\n            instruction[23];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[7] = height;\n            width = image.width;\n            instruction[14] = width;\n          }\n\n          var geometryWidths = void 0;\n\n          if (instruction.length > 24) {\n            geometryWidths =\n            /** @type {number} */\n            instruction[24];\n          }\n\n          var padding = void 0,\n              backgroundFill = void 0,\n              backgroundStroke = void 0;\n\n          if (instruction.length > 16) {\n            padding =\n            /** @type {Array<number>} */\n            instruction[15];\n            backgroundFill =\n            /** @type {boolean} */\n            instruction[16];\n            backgroundStroke =\n            /** @type {boolean} */\n            instruction[17];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n\n          var widthIndex = 0;\n          var declutterGroupIndex = 0;\n\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n\n            if (declutterGroups) {\n              var index = Math.floor(declutterGroupIndex);\n              declutterGroup = declutterGroups.length < index + 1 ? [declutterGroups[0][0]] : declutterGroups[index];\n            }\n\n            var rendered = this.replayImageOrLabel_(context, contextScale, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?\n            /** @type {Array<*>} */\n            lastFillInstruction : null, backgroundStroke ?\n            /** @type {Array<*>} */\n            lastStrokeInstruction : null);\n\n            if (rendered && declutterGroup && declutterGroups[declutterGroups.length - 1] !== declutterGroup) {\n              declutterGroups.push(declutterGroup);\n            }\n\n            if (declutterGroup) {\n              if (declutterGroup.length - 1 === declutterGroup[0]) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n\n              declutterGroupIndex += 1 / declutterGroup[0];\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_CHARS:\n          var begin =\n          /** @type {number} */\n          instruction[1];\n          var end =\n          /** @type {number} */\n          instruction[2];\n          var baseline =\n          /** @type {number} */\n          instruction[3];\n          declutterGroup = featureCallback ? null : instruction[4];\n          var overflow =\n          /** @type {number} */\n          instruction[5];\n          fillKey =\n          /** @type {string} */\n          instruction[6];\n          var maxAngle =\n          /** @type {number} */\n          instruction[7];\n          var measurePixelRatio =\n          /** @type {number} */\n          instruction[8];\n          var offsetY =\n          /** @type {number} */\n          instruction[9];\n          strokeKey =\n          /** @type {string} */\n          instruction[10];\n          var strokeWidth =\n          /** @type {number} */\n          instruction[11];\n          text =\n          /** @type {string} */\n          instruction[12];\n          textKey =\n          /** @type {string} */\n          instruction[13];\n          var pixelRatioScale = [\n          /** @type {number} */\n          instruction[14],\n          /** @type {number} */\n          instruction[14]];\n          var textState = this.textStates[textKey];\n          var font = textState.font;\n          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          var cachedWidths = void 0;\n\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n\n          if (overflow || textLength <= pathLength) {\n            var textAlign = this.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n\n            if (parts) {\n              var rendered = false;\n              var c = void 0,\n                  cc = void 0,\n                  chars = void 0,\n                  label = void 0,\n                  part = void 0;\n\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX =\n                  /** @type {number} */\n                  part[2] + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  rendered = this.replayImageOrLabel_(context, contextScale,\n                  /** @type {number} */\n                  part[0],\n                  /** @type {number} */\n                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                  /** @type {number} */\n                  part[3], pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;\n                }\n              }\n\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX =\n                  /** @type {number} */\n                  part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  rendered = this.replayImageOrLabel_(context, contextScale,\n                  /** @type {number} */\n                  part[0],\n                  /** @type {number} */\n                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                  /** @type {number} */\n                  part[3], pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;\n                }\n              }\n\n              if (rendered) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature =\n            /** @type {import(\"../../Feature.js\").FeatureLike} */\n            instruction[1];\n            var result = featureCallback(feature);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle =\n          /** @type {import(\"../../colorlike.js\").ColorLike} */\n          instruction[1];\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          this.setStrokeStyle_(context,\n          /** @type {Array<*>} */\n          instruction);\n          ++i;\n          break;\n\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n\n          ++i;\n          break;\n\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n\n          break;\n      }\n    }\n\n    if (pendingFill) {\n      this.fill_(context);\n    }\n\n    if (pendingStroke) {\n      context.stroke();\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   */\n\n\n  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n\n  return Executor;\n}();\n\nexport default Executor;","map":{"version":3,"sources":["../../src/render/canvas/Executor.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport RBush from 'rbush/rbush.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray, } from '../../transform.js';\nimport { createEmpty, createOrUpdate, getHeight, getWidth, intersects, } from '../../extent.js';\nimport { defaultPadding, defaultTextBaseline, drawImageOrLabel, } from '../canvas.js';\nimport { defaultTextAlign, measureAndCacheTextWidth, measureTextHeight, measureTextWidths, } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} textStates The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} fillStates The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} strokeStates The stroke states (decluttering).\n */\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = createEmpty();\n/**\n * @type {!import(\"../../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p4 = [];\nvar Executor = /** @class */ (function () {\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {boolean} overlaps The replay can have overlapping geometries.\n     * @param {SerializableInstructions} instructions The serializable instructions\n     * @param {import(\"../../size.js\").Size} renderBuffer Render buffer (width/height) in pixels.\n     */\n    function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {\n        /**\n         * @protected\n         * @type {boolean}\n         */\n        this.overlaps = overlaps;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        this.resolution = resolution;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.alignFill_;\n        /**\n         * @type {Array<*>}\n         */\n        this.declutterItems = [];\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.instructions = instructions.instructions;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        this.coordinates = instructions.coordinates;\n        /**\n         * @private\n         * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n         */\n        this.coordinateCache_ = {};\n        /**\n         * @private\n         * @type {import(\"../../size.js\").Size}\n         */\n        this.renderBuffer_ = renderBuffer;\n        /**\n         * @private\n         * @type {!import(\"../../transform.js\").Transform}\n         */\n        this.renderedTransform_ = createTransform();\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        this.pixelCoordinates_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.viewRotation_ = 0;\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").FillState>}\n         */\n        this.fillStates = instructions.fillStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n         */\n        this.strokeStates = instructions.strokeStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").TextState>}\n         */\n        this.textStates = instructions.textStates || {};\n        /**\n         * @private\n         * @type {Object<string, Object<string, number>>}\n         */\n        this.widths_ = {};\n        /**\n         * @private\n         * @type {Object<string, import(\"../canvas.js\").Label>}\n         */\n        this.labels_ = {};\n    }\n    /**\n     * @param {string} text Text.\n     * @param {string} textKey Text style key.\n     * @param {string} fillKey Fill style key.\n     * @param {string} strokeKey Stroke style key.\n     * @return {import(\"../canvas.js\").Label} Label.\n     */\n    Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n        var key = text + textKey + fillKey + strokeKey;\n        if (this.labels_[key]) {\n            return this.labels_[key];\n        }\n        var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n        var fillState = fillKey ? this.fillStates[fillKey] : null;\n        var textState = this.textStates[textKey];\n        var pixelRatio = this.pixelRatio;\n        var scale = [\n            textState.scale[0] * pixelRatio,\n            textState.scale[1] * pixelRatio,\n        ];\n        var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n        var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        var lines = text.split('\\n');\n        var numLines = lines.length;\n        var widths = [];\n        var width = measureTextWidths(textState.font, lines, widths);\n        var lineHeight = measureTextHeight(textState.font);\n        var height = lineHeight * numLines;\n        var renderWidth = width + strokeWidth;\n        var contextInstructions = [];\n        // make canvas 2 pixels wider to account for italic text width measurement errors\n        var w = (renderWidth + 2) * scale[0];\n        var h = (height + strokeWidth) * scale[1];\n        /** @type {import(\"../canvas.js\").Label} */\n        var label = {\n            width: w < 0 ? Math.floor(w) : Math.ceil(w),\n            height: h < 0 ? Math.floor(h) : Math.ceil(h),\n            contextInstructions: contextInstructions,\n        };\n        if (scale[0] != 1 || scale[1] != 1) {\n            contextInstructions.push('scale', scale);\n        }\n        contextInstructions.push('font', textState.font);\n        if (strokeKey) {\n            contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n            contextInstructions.push('lineWidth', strokeWidth);\n            contextInstructions.push('lineCap', strokeState.lineCap);\n            contextInstructions.push('lineJoin', strokeState.lineJoin);\n            contextInstructions.push('miterLimit', strokeState.miterLimit);\n            // eslint-disable-next-line\n            var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n            if (Context.prototype.setLineDash) {\n                contextInstructions.push('setLineDash', [strokeState.lineDash]);\n                contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n            }\n        }\n        if (fillKey) {\n            contextInstructions.push('fillStyle', fillState.fillStyle);\n        }\n        contextInstructions.push('textBaseline', 'middle');\n        contextInstructions.push('textAlign', 'center');\n        var leftRight = 0.5 - align;\n        var x = align * renderWidth + leftRight * strokeWidth;\n        var i;\n        if (strokeKey) {\n            for (i = 0; i < numLines; ++i) {\n                contextInstructions.push('strokeText', [\n                    lines[i],\n                    x + leftRight * widths[i],\n                    0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n                ]);\n            }\n        }\n        if (fillKey) {\n            for (i = 0; i < numLines; ++i) {\n                contextInstructions.push('fillText', [\n                    lines[i],\n                    x + leftRight * widths[i],\n                    0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n                ]);\n            }\n        }\n        this.labels_[key] = label;\n        return label;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     * @param {boolean} declutter Declutter.\n     */\n    Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction, declutter) {\n        context.beginPath();\n        context.moveTo.apply(context, p1);\n        context.lineTo.apply(context, p2);\n        context.lineTo.apply(context, p3);\n        context.lineTo.apply(context, p4);\n        context.lineTo.apply(context, p1);\n        if (fillInstruction) {\n            this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n            if (declutter) {\n                context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (fillInstruction[1]);\n            }\n            this.fill_(context);\n        }\n        if (strokeInstruction) {\n            this.setStrokeStyle_(context, \n            /** @type {Array<*>} */ (strokeInstruction));\n            context.stroke();\n        }\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n     * @param {number} anchorX Anchor X.\n     * @param {number} anchorY Anchor Y.\n     * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n     * @param {number} height Height.\n     * @param {number} opacity Opacity.\n     * @param {number} originX Origin X.\n     * @param {number} originY Origin Y.\n     * @param {number} rotation Rotation.\n     * @param {import(\"../../size.js\").Size} scale Scale.\n     * @param {boolean} snapToPixel Snap to pixel.\n     * @param {number} width Width.\n     * @param {Array<number>} padding Padding.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     * @return {boolean} The image or label was rendered.\n     */\n    Executor.prototype.replayImageOrLabel_ = function (context, contextScale, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n        var fillStroke = fillInstruction || strokeInstruction;\n        anchorX *= scale[0];\n        anchorY *= scale[1];\n        x -= anchorX;\n        y -= anchorY;\n        var w = width + originX > imageOrLabel.width\n            ? imageOrLabel.width - originX\n            : width;\n        var h = height + originY > imageOrLabel.height\n            ? imageOrLabel.height - originY\n            : height;\n        var boxW = padding[3] + w * scale[0] + padding[1];\n        var boxH = padding[0] + h * scale[1] + padding[2];\n        var boxX = x - padding[3];\n        var boxY = y - padding[0];\n        if (fillStroke || rotation !== 0) {\n            p1[0] = boxX;\n            p4[0] = boxX;\n            p1[1] = boxY;\n            p2[1] = boxY;\n            p2[0] = boxX + boxW;\n            p3[0] = p2[0];\n            p3[1] = boxY + boxH;\n            p4[1] = p3[1];\n        }\n        var transform = null;\n        if (rotation !== 0) {\n            var centerX = x + anchorX;\n            var centerY = y + anchorY;\n            transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n            applyTransform(tmpTransform, p1);\n            applyTransform(tmpTransform, p2);\n            applyTransform(tmpTransform, p3);\n            applyTransform(tmpTransform, p4);\n            createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n        }\n        else {\n            createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n        }\n        var renderBufferX = 0;\n        var renderBufferY = 0;\n        if (declutterGroup) {\n            var renderBuffer = this.renderBuffer_;\n            renderBuffer[0] = Math.max(renderBuffer[0], getWidth(tmpExtent));\n            renderBufferX = renderBuffer[0];\n            renderBuffer[1] = Math.max(renderBuffer[1], getHeight(tmpExtent));\n            renderBufferY = renderBuffer[1];\n        }\n        var canvas = context.canvas;\n        var strokePadding = strokeInstruction\n            ? (strokeInstruction[2] * scale[0]) / 2\n            : 0;\n        var intersects = tmpExtent[0] - strokePadding <=\n            (canvas.width + renderBufferX) / contextScale &&\n            tmpExtent[2] + strokePadding >= -renderBufferX / contextScale &&\n            tmpExtent[1] - strokePadding <=\n                (canvas.height + renderBufferY) / contextScale &&\n            tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;\n        if (snapToPixel) {\n            x = Math.round(x);\n            y = Math.round(y);\n        }\n        if (declutterGroup) {\n            if (!intersects && declutterGroup[0] == 1) {\n                return false;\n            }\n            var declutterArgs = intersects\n                ? [\n                    context,\n                    transform ? transform.slice(0) : null,\n                    opacity,\n                    imageOrLabel,\n                    originX,\n                    originY,\n                    w,\n                    h,\n                    x,\n                    y,\n                    scale,\n                    tmpExtent.slice(),\n                ]\n                : null;\n            if (declutterArgs) {\n                if (fillStroke) {\n                    declutterArgs.push(fillInstruction, strokeInstruction, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));\n                }\n                declutterGroup.push(declutterArgs);\n            }\n        }\n        else if (intersects) {\n            if (fillStroke) {\n                this.replayTextBackground_(context, p1, p2, p3, p4, \n                /** @type {Array<*>} */ (fillInstruction), \n                /** @type {Array<*>} */ (strokeInstruction), false);\n            }\n            drawImageOrLabel(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale);\n        }\n        return true;\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     */\n    Executor.prototype.fill_ = function (context) {\n        if (this.alignFill_) {\n            var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n            var repeatSize = 512 * this.pixelRatio;\n            context.save();\n            context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n            context.rotate(this.viewRotation_);\n        }\n        context.fill();\n        if (this.alignFill_) {\n            context.restore();\n        }\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {Array<*>} instruction Instruction.\n     */\n    Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n        context.strokeStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n        context.lineWidth = /** @type {number} */ (instruction[2]);\n        context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n        context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n        context.miterLimit = /** @type {number} */ (instruction[5]);\n        if (context.setLineDash) {\n            context.lineDashOffset = /** @type {number} */ (instruction[7]);\n            context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {number} opacity Layer opacity.\n     * @param {?} declutterTree Declutter tree.\n     * @return {?} Declutter tree.\n     */\n    Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {\n        /** @type {Array<import(\"../../structs/RBush.js\").Entry>} */\n        var boxes = [];\n        for (var i = 1, ii = declutterGroup.length; i < ii; ++i) {\n            var declutterData = declutterGroup[i];\n            var box = declutterData[11];\n            boxes.push({\n                minX: box[0],\n                minY: box[1],\n                maxX: box[2],\n                maxY: box[3],\n                value: feature,\n            });\n        }\n        if (!declutterTree) {\n            declutterTree = new RBush(9);\n        }\n        var collides = false;\n        for (var i = 0, ii = boxes.length; i < ii; ++i) {\n            if (declutterTree.collides(boxes[i])) {\n                collides = true;\n                break;\n            }\n        }\n        if (!collides) {\n            declutterTree.load(boxes);\n            for (var j = 1, jj = declutterGroup.length; j < jj; ++j) {\n                var declutterData = /** @type {Array} */ (declutterGroup[j]);\n                var context = declutterData[0];\n                var currentAlpha = context.globalAlpha;\n                if (currentAlpha !== opacity) {\n                    context.globalAlpha = opacity;\n                }\n                if (declutterData.length > 12) {\n                    this.replayTextBackground_(declutterData[0], declutterData[14], declutterData[15], declutterData[16], declutterData[17], declutterData[12], declutterData[13], true);\n                }\n                drawImageOrLabel.apply(undefined, declutterData);\n                if (currentAlpha !== opacity) {\n                    context.globalAlpha = currentAlpha;\n                }\n            }\n        }\n        declutterGroup.length = 1;\n        return declutterTree;\n    };\n    /**\n     * @private\n     * @param {string} text The text to draw.\n     * @param {string} textKey The key of the text state.\n     * @param {string} strokeKey The key for the stroke state.\n     * @param {string} fillKey The key for the fill state.\n     * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n     */\n    Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n        var textState = this.textStates[textKey];\n        var label = this.createLabel(text, textKey, fillKey, strokeKey);\n        var strokeState = this.strokeStates[strokeKey];\n        var pixelRatio = this.pixelRatio;\n        var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n        var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        // Remove the 2 pixels we added in createLabel() for the anchor\n        var width = label.width / pixelRatio - 2 * textState.scale[0];\n        var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n        var anchorY = (baseline * label.height) / pixelRatio +\n            2 * (0.5 - baseline) * strokeWidth;\n        return {\n            label: label,\n            anchorX: anchorX,\n            anchorY: anchorY,\n        };\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {Array<*>} instructions Instructions array.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {function(import(\"../../Feature.js\").FeatureLike): T|undefined} featureCallback Feature callback.\n     * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n     *     extent.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {\n        this.declutterItems.length = 0;\n        /** @type {Array<number>} */\n        var pixelCoordinates;\n        if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n            pixelCoordinates = this.pixelCoordinates_;\n        }\n        else {\n            if (!this.pixelCoordinates_) {\n                this.pixelCoordinates_ = [];\n            }\n            pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n            transformSetFromArray(this.renderedTransform_, transform);\n        }\n        var i = 0; // instruction index\n        var ii = instructions.length; // end of instructions\n        var d = 0; // data index\n        var dd; // end of per-instruction data\n        var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;\n        var strokeKey, fillKey;\n        var pendingFill = 0;\n        var pendingStroke = 0;\n        var lastFillInstruction = null;\n        var lastStrokeInstruction = null;\n        var coordinateCache = this.coordinateCache_;\n        var viewRotation = this.viewRotation_;\n        var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n        var state = /** @type {import(\"../../render.js\").State} */ ({\n            context: context,\n            pixelRatio: this.pixelRatio,\n            resolution: this.resolution,\n            rotation: viewRotation,\n        });\n        // When the batch size gets too big, performance decreases. 200 is a good\n        // balance between batch size and number of fill/stroke instructions.\n        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n        var /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\n        var x, y;\n        while (i < ii) {\n            var instruction = instructions[i];\n            var type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n            switch (type) {\n                case CanvasInstruction.BEGIN_GEOMETRY:\n                    feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                    if (!feature.getGeometry()) {\n                        i = /** @type {number} */ (instruction[2]);\n                    }\n                    else if (opt_hitExtent !== undefined &&\n                        !intersects(opt_hitExtent, instruction[3])) {\n                        i = /** @type {number} */ (instruction[2]) + 1;\n                    }\n                    else {\n                        ++i;\n                    }\n                    break;\n                case CanvasInstruction.BEGIN_PATH:\n                    if (pendingFill > batchSize) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                    }\n                    if (pendingStroke > batchSize) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    if (!pendingFill && !pendingStroke) {\n                        context.beginPath();\n                        prevX = NaN;\n                        prevY = NaN;\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.CIRCLE:\n                    d = /** @type {number} */ (instruction[1]);\n                    var x1 = pixelCoordinates[d];\n                    var y1 = pixelCoordinates[d + 1];\n                    var x2 = pixelCoordinates[d + 2];\n                    var y2 = pixelCoordinates[d + 3];\n                    var dx = x2 - x1;\n                    var dy = y2 - y1;\n                    var r = Math.sqrt(dx * dx + dy * dy);\n                    context.moveTo(x1 + r, y1);\n                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n                    ++i;\n                    break;\n                case CanvasInstruction.CLOSE_PATH:\n                    context.closePath();\n                    ++i;\n                    break;\n                case CanvasInstruction.CUSTOM:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = instruction[2];\n                    var geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (instruction[3]);\n                    var renderer = instruction[4];\n                    var fn = instruction.length == 6 ? instruction[5] : undefined;\n                    state.geometry = geometry;\n                    state.feature = feature;\n                    if (!(i in coordinateCache)) {\n                        coordinateCache[i] = [];\n                    }\n                    var coords = coordinateCache[i];\n                    if (fn) {\n                        fn(pixelCoordinates, d, dd, 2, coords);\n                    }\n                    else {\n                        coords[0] = pixelCoordinates[d];\n                        coords[1] = pixelCoordinates[d + 1];\n                        coords.length = 2;\n                    }\n                    renderer(coords, state);\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_IMAGE:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);\n                    // Remaining arguments in DRAW_IMAGE are in alphabetical order\n                    anchorX = /** @type {number} */ (instruction[4]);\n                    anchorY = /** @type {number} */ (instruction[5]);\n                    declutterGroups = featureCallback ? null : instruction[6];\n                    var height = /** @type {number} */ (instruction[7]);\n                    var opacity = /** @type {number} */ (instruction[8]);\n                    var originX = /** @type {number} */ (instruction[9]);\n                    var originY = /** @type {number} */ (instruction[10]);\n                    var rotateWithView = /** @type {boolean} */ (instruction[11]);\n                    var rotation = /** @type {number} */ (instruction[12]);\n                    var scale = /** @type {import(\"../../size.js\").Size} */ (instruction[13]);\n                    var width = /** @type {number} */ (instruction[14]);\n                    if (!image && instruction.length >= 19) {\n                        // create label images\n                        text = /** @type {string} */ (instruction[18]);\n                        textKey = /** @type {string} */ (instruction[19]);\n                        strokeKey = /** @type {string} */ (instruction[20]);\n                        fillKey = /** @type {string} */ (instruction[21]);\n                        var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n                        image = labelWithAnchor.label;\n                        instruction[3] = image;\n                        var textOffsetX = /** @type {number} */ (instruction[22]);\n                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n                        instruction[4] = anchorX;\n                        var textOffsetY = /** @type {number} */ (instruction[23]);\n                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n                        instruction[5] = anchorY;\n                        height = image.height;\n                        instruction[7] = height;\n                        width = image.width;\n                        instruction[14] = width;\n                    }\n                    var geometryWidths = void 0;\n                    if (instruction.length > 24) {\n                        geometryWidths = /** @type {number} */ (instruction[24]);\n                    }\n                    var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;\n                    if (instruction.length > 16) {\n                        padding = /** @type {Array<number>} */ (instruction[15]);\n                        backgroundFill = /** @type {boolean} */ (instruction[16]);\n                        backgroundStroke = /** @type {boolean} */ (instruction[17]);\n                    }\n                    else {\n                        padding = defaultPadding;\n                        backgroundFill = false;\n                        backgroundStroke = false;\n                    }\n                    if (rotateWithView && viewRotationFromTransform) {\n                        // Canvas is expected to be rotated to reverse view rotation.\n                        rotation += viewRotation;\n                    }\n                    else if (!rotateWithView && !viewRotationFromTransform) {\n                        // Canvas is not rotated, images need to be rotated back to be north-up.\n                        rotation -= viewRotation;\n                    }\n                    var widthIndex = 0;\n                    var declutterGroupIndex = 0;\n                    for (; d < dd; d += 2) {\n                        if (geometryWidths &&\n                            geometryWidths[widthIndex++] < width / this.pixelRatio) {\n                            continue;\n                        }\n                        if (declutterGroups) {\n                            var index = Math.floor(declutterGroupIndex);\n                            declutterGroup =\n                                declutterGroups.length < index + 1\n                                    ? [declutterGroups[0][0]]\n                                    : declutterGroups[index];\n                        }\n                        var rendered = this.replayImageOrLabel_(context, contextScale, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill\n                            ? /** @type {Array<*>} */ (lastFillInstruction)\n                            : null, backgroundStroke\n                            ? /** @type {Array<*>} */ (lastStrokeInstruction)\n                            : null);\n                        if (rendered &&\n                            declutterGroup &&\n                            declutterGroups[declutterGroups.length - 1] !== declutterGroup) {\n                            declutterGroups.push(declutterGroup);\n                        }\n                        if (declutterGroup) {\n                            if (declutterGroup.length - 1 === declutterGroup[0]) {\n                                this.declutterItems.push(this, declutterGroup, feature);\n                            }\n                            declutterGroupIndex += 1 / declutterGroup[0];\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_CHARS:\n                    var begin = /** @type {number} */ (instruction[1]);\n                    var end = /** @type {number} */ (instruction[2]);\n                    var baseline = /** @type {number} */ (instruction[3]);\n                    declutterGroup = featureCallback ? null : instruction[4];\n                    var overflow = /** @type {number} */ (instruction[5]);\n                    fillKey = /** @type {string} */ (instruction[6]);\n                    var maxAngle = /** @type {number} */ (instruction[7]);\n                    var measurePixelRatio = /** @type {number} */ (instruction[8]);\n                    var offsetY = /** @type {number} */ (instruction[9]);\n                    strokeKey = /** @type {string} */ (instruction[10]);\n                    var strokeWidth = /** @type {number} */ (instruction[11]);\n                    text = /** @type {string} */ (instruction[12]);\n                    textKey = /** @type {string} */ (instruction[13]);\n                    var pixelRatioScale = [\n                        /** @type {number} */ (instruction[14]),\n                        /** @type {number} */ (instruction[14]),\n                    ];\n                    var textState = this.textStates[textKey];\n                    var font = textState.font;\n                    var textScale = [\n                        textState.scale[0] * measurePixelRatio,\n                        textState.scale[1] * measurePixelRatio,\n                    ];\n                    var cachedWidths = void 0;\n                    if (font in this.widths_) {\n                        cachedWidths = this.widths_[font];\n                    }\n                    else {\n                        cachedWidths = {};\n                        this.widths_[font] = cachedWidths;\n                    }\n                    var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n                    var textLength = Math.abs(textScale[0]) *\n                        measureAndCacheTextWidth(font, text, cachedWidths);\n                    if (overflow || textLength <= pathLength) {\n                        var textAlign = this.textStates[textKey].textAlign;\n                        var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n                        var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n                        if (parts) {\n                            var rendered = false;\n                            var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;\n                            if (strokeKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, '', strokeKey);\n                                    anchorX = /** @type {number} */ (part[2]) + strokeWidth;\n                                    anchorY =\n                                        baseline * label.height +\n                                            ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\n                                                textScale[0] -\n                                            offsetY;\n                                    rendered =\n                                        this.replayImageOrLabel_(context, contextScale, \n                                        /** @type {number} */ (part[0]), \n                                        /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, \n                                        /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;\n                                }\n                            }\n                            if (fillKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, fillKey, '');\n                                    anchorX = /** @type {number} */ (part[2]);\n                                    anchorY = baseline * label.height - offsetY;\n                                    rendered =\n                                        this.replayImageOrLabel_(context, contextScale, \n                                        /** @type {number} */ (part[0]), \n                                        /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, \n                                        /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;\n                                }\n                            }\n                            if (rendered) {\n                                this.declutterItems.push(this, declutterGroup, feature);\n                            }\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.END_GEOMETRY:\n                    if (featureCallback !== undefined) {\n                        feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                        var result = featureCallback(feature);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.FILL:\n                    if (batchSize) {\n                        pendingFill++;\n                    }\n                    else {\n                        this.fill_(context);\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.MOVE_TO_LINE_TO:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    x = pixelCoordinates[d];\n                    y = pixelCoordinates[d + 1];\n                    roundX = (x + 0.5) | 0;\n                    roundY = (y + 0.5) | 0;\n                    if (roundX !== prevX || roundY !== prevY) {\n                        context.moveTo(x, y);\n                        prevX = roundX;\n                        prevY = roundY;\n                    }\n                    for (d += 2; d < dd; d += 2) {\n                        x = pixelCoordinates[d];\n                        y = pixelCoordinates[d + 1];\n                        roundX = (x + 0.5) | 0;\n                        roundY = (y + 0.5) | 0;\n                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n                            context.lineTo(x, y);\n                            prevX = roundX;\n                            prevY = roundY;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_FILL_STYLE:\n                    lastFillInstruction = instruction;\n                    this.alignFill_ = instruction[2];\n                    if (pendingFill) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                        if (pendingStroke) {\n                            context.stroke();\n                            pendingStroke = 0;\n                        }\n                    }\n                    context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_STROKE_STYLE:\n                    lastStrokeInstruction = instruction;\n                    if (pendingStroke) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n                    ++i;\n                    break;\n                case CanvasInstruction.STROKE:\n                    if (batchSize) {\n                        pendingStroke++;\n                    }\n                    else {\n                        context.stroke();\n                    }\n                    ++i;\n                    break;\n                default:\n                    ++i; // consume the instruction anyway, to avoid an infinite loop\n                    break;\n            }\n        }\n        if (pendingFill) {\n            this.fill_(context);\n        }\n        if (pendingStroke) {\n            context.stroke();\n        }\n        return undefined;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     */\n    Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel) {\n        this.viewRotation_ = viewRotation;\n        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined);\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {function(import(\"../../Feature.js\").FeatureLike): T=} opt_featureCallback\n     *     Feature callback.\n     * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n     *     extent.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n        this.viewRotation_ = viewRotation;\n        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n    };\n    return Executor;\n}());\nexport default Executor;\n//# sourceMappingURL=Executor.js.map"]},"metadata":{},"sourceType":"module"}