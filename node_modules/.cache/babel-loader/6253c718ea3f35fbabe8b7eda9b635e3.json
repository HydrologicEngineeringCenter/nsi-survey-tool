{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { equals } from '../array.js';\nimport { fromKey, getKeyZXY } from '../tilecoord.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nvar VectorTile =\n/** @class */\nfunction (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n\n\n  function VectorTile(options) {\n    var _this = this;\n\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || extentFromProjection(projection);\n    var tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n\n    _this.format_ = options.format ? options.format : null;\n    /**\n     * @type {Object<string, import(\"./VectorTile\").default>}\n     */\n\n    _this.loadingTiles_ = {};\n    /**\n     * @private\n     * @type {TileCache}\n     */\n\n    _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n\n    _this.tileClass = options.tileClass ? options.tileClass : Tile;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n\n    _this.tileGrids_ = {};\n    return _this;\n  }\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  VectorTile.prototype.getFeaturesInExtent = function (extent) {\n    var features = [];\n    var tileCache = this.tileCache;\n\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n\n    var z = fromKey(tileCache.peekFirstKey())[0];\n    var tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n\n      var sourceTiles = tile.getSourceTiles();\n\n      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        var sourceTile = sourceTiles[i];\n        var tileCoord = sourceTile.tileCoord;\n\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          var tileFeatures = sourceTile.getFeatures();\n\n          if (tileFeatures) {\n            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              var candidate = tileFeatures[j];\n              var geometry = candidate.getGeometry();\n\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  };\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n\n\n  VectorTile.prototype.getOverlaps = function () {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n\n\n  VectorTile.prototype.clear = function () {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  VectorTile.prototype.expireCache = function (projection, usedTiles) {\n    _super.prototype.expireCache.call(this, projection, usedTiles);\n\n    this.sourceTileCache.expireCache({});\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n\n\n  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n    var urlTileCoord = tile.wrappedTileCoord;\n    var tileGrid = this.getTileGridForProjection(projection);\n    var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n    var z = urlTileCoord[0];\n    var resolution = tileGrid.getResolution(z); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n    bufferExtent(extent, -resolution, extent);\n    var sourceTileGrid = this.tileGrid;\n    var sourceExtent = sourceTileGrid.getExtent();\n\n    if (sourceExtent) {\n      getIntersection(extent, sourceExtent, extent);\n    }\n\n    var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n    var minZoom = sourceTileGrid.getMinZoom();\n    var previousSourceTiles = tile.sourceTiles;\n    var sourceTiles, covered, loadedZ;\n\n    if (previousSourceTiles && previousSourceTiles.length > 0 && previousSourceTiles[0].tileCoord[0] === sourceZ) {\n      sourceTiles = previousSourceTiles;\n      covered = true;\n      loadedZ = sourceZ;\n    } else {\n      sourceTiles = [];\n      loadedZ = sourceZ + 1;\n\n      do {\n        --loadedZ;\n        covered = true;\n        sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {\n          var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n          var sourceTile;\n\n          if (tileUrl !== undefined) {\n            if (this.sourceTileCache.containsKey(tileUrl)) {\n              sourceTile = this.sourceTileCache.get(tileUrl);\n              var state = sourceTile.getState();\n\n              if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {\n                sourceTiles.push(sourceTile);\n                return;\n              }\n            } else if (loadedZ === sourceZ) {\n              sourceTile = new this.tileClass(sourceTileCoord, TileState.IDLE, tileUrl, this.format_, this.tileLoadFunction);\n              sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n              sourceTile.projection = projection;\n              sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n              this.sourceTileCache.set(tileUrl, sourceTile);\n              sourceTile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n              sourceTile.load();\n            }\n          }\n\n          covered = covered && sourceTile && sourceTile.getState() === TileState.LOADED;\n\n          if (!sourceTile) {\n            return;\n          }\n\n          if (sourceTile.getState() !== TileState.EMPTY && tile.getState() === TileState.IDLE) {\n            tile.loadingSourceTiles++;\n            sourceTile.addEventListener(EventType.CHANGE, function listenChange() {\n              var state = sourceTile.getState();\n              var sourceTileKey = sourceTile.getKey();\n\n              if (state === TileState.LOADED || state === TileState.ERROR) {\n                if (state === TileState.LOADED) {\n                  sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n                  tile.loadingSourceTiles--;\n                  delete tile.errorSourceTileKeys[sourceTileKey];\n                } else if (state === TileState.ERROR) {\n                  tile.errorSourceTileKeys[sourceTileKey] = true;\n                }\n\n                var errorTileCount = Object.keys(tile.errorSourceTileKeys).length;\n\n                if (tile.loadingSourceTiles - errorTileCount === 0) {\n                  tile.hifi = errorTileCount === 0;\n                  tile.sourceZ = sourceZ;\n                  tile.setState(TileState.LOADED);\n                }\n              }\n            });\n          }\n        }.bind(this));\n\n        if (!covered) {\n          sourceTiles.length = 0;\n        }\n      } while (!covered && loadedZ > minZoom);\n    }\n\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n    }\n\n    if (covered) {\n      tile.hifi = sourceZ === loadedZ;\n      tile.sourceZ = loadedZ;\n\n      if (tile.getState() < TileState.LOADED) {\n        tile.setState(TileState.LOADED);\n      } else if (!previousSourceTiles || !equals(sourceTiles, previousSourceTiles)) {\n        tile.sourceTiles = sourceTiles;\n      }\n    }\n\n    return sourceTiles;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n\n\n  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var coordKey = getKeyZXY(z, x, y);\n    var key = this.getKey();\n    var tile;\n\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var sourceExtent = this.getTileGrid().getExtent();\n    var tileGrid = this.getTileGridForProjection(projection);\n\n    if (urlTileCoord && sourceExtent) {\n      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n\n    var empty = true;\n\n    if (urlTileCoord !== null) {\n      var sourceTileGrid = this.tileGrid;\n      var resolution = tileGrid.getResolution(z);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n\n    var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n    newTile.key = key;\n\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n\n    return newTile;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n\n\n  VectorTile.prototype.getTileGridForProjection = function (projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n      this.tileGrids_[code] = tileGrid;\n    }\n\n    return tileGrid;\n  };\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n\n\n  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n\n\n  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n  };\n\n  return VectorTile;\n}(UrlTile);\n\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\n\nexport function defaultLoadFunction(tile, url) {\n  var loader = loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n  tile.setLoader(loader);\n}","map":{"version":3,"sources":["../src/source/VectorTile.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/source/VectorTile\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects, } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection, } from '../tilegrid.js';\nimport { equals } from '../array.js';\nimport { fromKey, getKeyZXY } from '../tilecoord.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /** @class */ (function (_super) {\n    __extends(VectorTile, _super);\n    /**\n     * @param {!Options} options Vector tile options.\n     */\n    function VectorTile(options) {\n        var _this = this;\n        var projection = options.projection || 'EPSG:3857';\n        var extent = options.extent || extentFromProjection(projection);\n        var tileGrid = options.tileGrid ||\n            createXYZ({\n                extent: extent,\n                maxResolution: options.maxResolution,\n                maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n                minZoom: options.minZoom,\n                tileSize: options.tileSize || 512,\n            });\n        _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            cacheSize: options.cacheSize,\n            opaque: false,\n            projection: projection,\n            state: options.state,\n            tileGrid: tileGrid,\n            tileLoadFunction: options.tileLoadFunction\n                ? options.tileLoadFunction\n                : defaultLoadFunction,\n            tileUrlFunction: options.tileUrlFunction,\n            url: options.url,\n            urls: options.urls,\n            wrapX: options.wrapX === undefined ? true : options.wrapX,\n            transition: options.transition,\n            zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {import(\"../format/Feature.js\").default}\n         */\n        _this.format_ = options.format ? options.format : null;\n        /**\n         * @type {Object<string, import(\"./VectorTile\").default>}\n         */\n        _this.loadingTiles_ = {};\n        /**\n         * @private\n         * @type {TileCache}\n         */\n        _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n        /**\n         * @protected\n         * @type {typeof import(\"../VectorTile.js\").default}\n         */\n        _this.tileClass = options.tileClass ? options.tileClass : Tile;\n        /**\n         * @private\n         * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n         */\n        _this.tileGrids_ = {};\n        return _this;\n    }\n    /**\n     * Get features whose bounding box intersects the provided extent. Only features for cached\n     * tiles for the last rendered zoom level are available in the source. So this method is only\n     * suitable for requesting tiles for extents that are currently rendered.\n     *\n     * Features are returned in random tile order and as they are included in the tiles. This means\n     * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     * @api\n     */\n    VectorTile.prototype.getFeaturesInExtent = function (extent) {\n        var features = [];\n        var tileCache = this.tileCache;\n        if (tileCache.getCount() === 0) {\n            return features;\n        }\n        var z = fromKey(tileCache.peekFirstKey())[0];\n        var tileGrid = this.tileGrid;\n        tileCache.forEach(function (tile) {\n            if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n                return;\n            }\n            var sourceTiles = tile.getSourceTiles();\n            for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n                var sourceTile = sourceTiles[i];\n                var tileCoord = sourceTile.tileCoord;\n                if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n                    var tileFeatures = sourceTile.getFeatures();\n                    if (tileFeatures) {\n                        for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n                            var candidate = tileFeatures[j];\n                            var geometry = candidate.getGeometry();\n                            if (intersects(extent, geometry.getExtent())) {\n                                features.push(candidate);\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return features;\n    };\n    /**\n     * @return {boolean} The source can have overlapping geometries.\n     */\n    VectorTile.prototype.getOverlaps = function () {\n        return this.overlaps_;\n    };\n    /**\n     * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n     * @api\n     */\n    VectorTile.prototype.clear = function () {\n        this.tileCache.clear();\n        this.sourceTileCache.clear();\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    VectorTile.prototype.expireCache = function (projection, usedTiles) {\n        _super.prototype.expireCache.call(this, projection, usedTiles);\n        this.sourceTileCache.expireCache({});\n    };\n    /**\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection\").default} projection Projection.\n     * @param {VectorRenderTile} tile Vector image tile.\n     * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n     */\n    VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n        var urlTileCoord = tile.wrappedTileCoord;\n        var tileGrid = this.getTileGridForProjection(projection);\n        var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n        var z = urlTileCoord[0];\n        var resolution = tileGrid.getResolution(z);\n        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n        bufferExtent(extent, -resolution, extent);\n        var sourceTileGrid = this.tileGrid;\n        var sourceExtent = sourceTileGrid.getExtent();\n        if (sourceExtent) {\n            getIntersection(extent, sourceExtent, extent);\n        }\n        var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n        var minZoom = sourceTileGrid.getMinZoom();\n        var previousSourceTiles = tile.sourceTiles;\n        var sourceTiles, covered, loadedZ;\n        if (previousSourceTiles &&\n            previousSourceTiles.length > 0 &&\n            previousSourceTiles[0].tileCoord[0] === sourceZ) {\n            sourceTiles = previousSourceTiles;\n            covered = true;\n            loadedZ = sourceZ;\n        }\n        else {\n            sourceTiles = [];\n            loadedZ = sourceZ + 1;\n            do {\n                --loadedZ;\n                covered = true;\n                sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {\n                    var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n                    var sourceTile;\n                    if (tileUrl !== undefined) {\n                        if (this.sourceTileCache.containsKey(tileUrl)) {\n                            sourceTile = this.sourceTileCache.get(tileUrl);\n                            var state = sourceTile.getState();\n                            if (state === TileState.LOADED ||\n                                state === TileState.ERROR ||\n                                state === TileState.EMPTY) {\n                                sourceTiles.push(sourceTile);\n                                return;\n                            }\n                        }\n                        else if (loadedZ === sourceZ) {\n                            sourceTile = new this.tileClass(sourceTileCoord, TileState.IDLE, tileUrl, this.format_, this.tileLoadFunction);\n                            sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n                            sourceTile.projection = projection;\n                            sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n                            this.sourceTileCache.set(tileUrl, sourceTile);\n                            sourceTile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n                            sourceTile.load();\n                        }\n                    }\n                    covered =\n                        covered &&\n                            sourceTile &&\n                            sourceTile.getState() === TileState.LOADED;\n                    if (!sourceTile) {\n                        return;\n                    }\n                    if (sourceTile.getState() !== TileState.EMPTY &&\n                        tile.getState() === TileState.IDLE) {\n                        tile.loadingSourceTiles++;\n                        sourceTile.addEventListener(EventType.CHANGE, function listenChange() {\n                            var state = sourceTile.getState();\n                            var sourceTileKey = sourceTile.getKey();\n                            if (state === TileState.LOADED || state === TileState.ERROR) {\n                                if (state === TileState.LOADED) {\n                                    sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n                                    tile.loadingSourceTiles--;\n                                    delete tile.errorSourceTileKeys[sourceTileKey];\n                                }\n                                else if (state === TileState.ERROR) {\n                                    tile.errorSourceTileKeys[sourceTileKey] = true;\n                                }\n                                var errorTileCount = Object.keys(tile.errorSourceTileKeys)\n                                    .length;\n                                if (tile.loadingSourceTiles - errorTileCount === 0) {\n                                    tile.hifi = errorTileCount === 0;\n                                    tile.sourceZ = sourceZ;\n                                    tile.setState(TileState.LOADED);\n                                }\n                            }\n                        });\n                    }\n                }.bind(this));\n                if (!covered) {\n                    sourceTiles.length = 0;\n                }\n            } while (!covered && loadedZ > minZoom);\n        }\n        if (tile.getState() === TileState.IDLE) {\n            tile.setState(TileState.LOADING);\n        }\n        if (covered) {\n            tile.hifi = sourceZ === loadedZ;\n            tile.sourceZ = loadedZ;\n            if (tile.getState() < TileState.LOADED) {\n                tile.setState(TileState.LOADED);\n            }\n            else if (!previousSourceTiles ||\n                !equals(sourceTiles, previousSourceTiles)) {\n                tile.sourceTiles = sourceTiles;\n            }\n        }\n        return sourceTiles;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!VectorRenderTile} Tile.\n     */\n    VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var coordKey = getKeyZXY(z, x, y);\n        var key = this.getKey();\n        var tile;\n        if (this.tileCache.containsKey(coordKey)) {\n            tile = this.tileCache.get(coordKey);\n            if (tile.key === key) {\n                return tile;\n            }\n        }\n        var tileCoord = [z, x, y];\n        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var sourceExtent = this.getTileGrid().getExtent();\n        var tileGrid = this.getTileGridForProjection(projection);\n        if (urlTileCoord && sourceExtent) {\n            var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n            if (!intersects(sourceExtent, tileExtent)) {\n                urlTileCoord = null;\n            }\n        }\n        var empty = true;\n        if (urlTileCoord !== null) {\n            var sourceTileGrid = this.tileGrid;\n            var resolution = tileGrid.getResolution(z);\n            var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n            bufferExtent(extent, -resolution, extent);\n            sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n                empty =\n                    empty &&\n                        !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            }.bind(this));\n        }\n        var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n        newTile.key = key;\n        if (tile) {\n            newTile.interimTile = tile;\n            newTile.refreshInterimChain();\n            this.tileCache.replace(coordKey, newTile);\n        }\n        else {\n            this.tileCache.set(coordKey, newTile);\n        }\n        return newTile;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    VectorTile.prototype.getTileGridForProjection = function (projection) {\n        var code = projection.getCode();\n        var tileGrid = this.tileGrids_[code];\n        if (!tileGrid) {\n            // A tile grid that matches the tile size of the source tile grid is more\n            // likely to have 1:1 relationships between source tiles and rendered tiles.\n            var sourceTileGrid = this.tileGrid;\n            tileGrid = createForProjection(projection, undefined, sourceTileGrid\n                ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom())\n                : undefined);\n            this.tileGrids_[code] = tileGrid;\n        }\n        return tileGrid;\n    };\n    /**\n     * Get the tile pixel ratio for this source.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n    VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n        return pixelRatio;\n    };\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n    VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n        return [\n            Math.round(tileSize[0] * pixelRatio),\n            Math.round(tileSize[1] * pixelRatio),\n        ];\n    };\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n        _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n    };\n    return VectorTile;\n}(UrlTile));\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n    var loader = loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n    tile.setLoader(loader);\n}\n//# sourceMappingURL=VectorTile.js.map"]},"metadata":{},"sourceType":"module"}