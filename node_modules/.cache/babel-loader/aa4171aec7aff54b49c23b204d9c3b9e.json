{"ast":null,"code":"/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/a/1180256/2389327\n  // https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\n  var firstVertexRepeated = true;\n\n  for (var i = 0; i < stride; ++i) {\n    if (flatCoordinates[offset + i] !== flatCoordinates[end - stride + i]) {\n      firstVertexRepeated = false;\n      break;\n    }\n  }\n\n  if (firstVertexRepeated) {\n    end -= stride;\n  }\n\n  var iMinVertex = findCornerVertex(flatCoordinates, offset, end, stride); // Orientation matrix:\n  //     [ 1  xa  ya ]\n  // O = | 1  xb  yb |\n  //     [ 1  xc  yc ]\n\n  var iPreviousVertex = iMinVertex - stride;\n\n  if (iPreviousVertex < offset) {\n    iPreviousVertex = end - stride;\n  }\n\n  var iNextVertex = iMinVertex + stride;\n\n  if (iNextVertex >= end) {\n    iNextVertex = offset;\n  }\n\n  var aX = flatCoordinates[iPreviousVertex];\n  var aY = flatCoordinates[iPreviousVertex + 1];\n  var bX = flatCoordinates[iMinVertex];\n  var bY = flatCoordinates[iMinVertex + 1];\n  var cX = flatCoordinates[iNextVertex];\n  var cY = flatCoordinates[iNextVertex + 1];\n  var determinant = bX * cY + aX * bY + aY * cX - (aY * bX + bY * cX + aX * cY);\n  return determinant < 0;\n} // Find vertex along one edge of bounding box.\n// In this case, we find smallest y; in case of tie also smallest x.\n\nfunction findCornerVertex(flatCoordinates, offset, end, stride) {\n  var iMinVertex = -1;\n  var minY = Infinity;\n  var minXAtMinY = Infinity;\n\n  for (var i = offset; i < end; i += stride) {\n    var x = flatCoordinates[i];\n    var y = flatCoordinates[i + 1];\n\n    if (y > minY) {\n      continue;\n    }\n\n    if (y == minY) {\n      if (x >= minXAtMinY) {\n        continue;\n      }\n    } // Minimum so far.\n\n\n    iMinVertex = i;\n    minY = y;\n    minXAtMinY = x;\n  }\n\n  return iMinVertex;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\n\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n\n    offset = end;\n  }\n\n  return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n      return false;\n    }\n\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n\n  return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n\n    offset = end;\n  }\n\n  return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n\n  return offset;\n}","map":{"version":3,"sources":["../../src/geom/flat/orient.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n    // https://stackoverflow.com/a/1180256/2389327\n    // https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\n    var firstVertexRepeated = true;\n    for (var i = 0; i < stride; ++i) {\n        if (flatCoordinates[offset + i] !== flatCoordinates[end - stride + i]) {\n            firstVertexRepeated = false;\n            break;\n        }\n    }\n    if (firstVertexRepeated) {\n        end -= stride;\n    }\n    var iMinVertex = findCornerVertex(flatCoordinates, offset, end, stride);\n    // Orientation matrix:\n    //     [ 1  xa  ya ]\n    // O = | 1  xb  yb |\n    //     [ 1  xc  yc ]\n    var iPreviousVertex = iMinVertex - stride;\n    if (iPreviousVertex < offset) {\n        iPreviousVertex = end - stride;\n    }\n    var iNextVertex = iMinVertex + stride;\n    if (iNextVertex >= end) {\n        iNextVertex = offset;\n    }\n    var aX = flatCoordinates[iPreviousVertex];\n    var aY = flatCoordinates[iPreviousVertex + 1];\n    var bX = flatCoordinates[iMinVertex];\n    var bY = flatCoordinates[iMinVertex + 1];\n    var cX = flatCoordinates[iNextVertex];\n    var cY = flatCoordinates[iNextVertex + 1];\n    var determinant = bX * cY + aX * bY + aY * cX - (aY * bX + bY * cX + aX * cY);\n    return determinant < 0;\n}\n// Find vertex along one edge of bounding box.\n// In this case, we find smallest y; in case of tie also smallest x.\nfunction findCornerVertex(flatCoordinates, offset, end, stride) {\n    var iMinVertex = -1;\n    var minY = Infinity;\n    var minXAtMinY = Infinity;\n    for (var i = offset; i < end; i += stride) {\n        var x = flatCoordinates[i];\n        var y = flatCoordinates[i + 1];\n        if (y > minY) {\n            continue;\n        }\n        if (y == minY) {\n            if (x >= minXAtMinY) {\n                continue;\n            }\n        }\n        // Minimum so far.\n        iMinVertex = i;\n        minY = y;\n        minXAtMinY = x;\n    }\n    return iMinVertex;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        if (i === 0) {\n            if ((right && isClockwise) || (!right && !isClockwise)) {\n                return false;\n            }\n        }\n        else {\n            if ((right && !isClockwise) || (!right && isClockwise)) {\n                return false;\n            }\n        }\n        offset = end;\n    }\n    return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n            return false;\n        }\n        if (ends.length) {\n            offset = ends[ends.length - 1];\n        }\n    }\n    return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        var reverse = i === 0\n            ? (right && isClockwise) || (!right && !isClockwise)\n            : (right && !isClockwise) || (!right && isClockwise);\n        if (reverse) {\n            reverseCoordinates(flatCoordinates, offset, end, stride);\n        }\n        offset = end;\n    }\n    return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n    }\n    return offset;\n}\n//# sourceMappingURL=orient.js.map"]},"metadata":{},"sourceType":"module"}